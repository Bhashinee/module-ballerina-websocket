diff --git a/websocket-ballerina/websocket_caller.bal b/websocket-ballerina/websocket_caller.bal
index 350356c3f..e3f21900f 100644
--- a/websocket-ballerina/websocket_caller.bal
+++ b/websocket-ballerina/websocket_caller.bal
@@ -14,14 +14,16 @@
 // specific language governing permissions and limitations
 // under the License.
 
+import ballerina/jballerina.java;
+
 # Represents a WebSocket caller.
-public client class Caller {
+public isolated client class Caller {
 
     private string id = "";
     private string? negotiatedSubProtocol = ();
     private boolean secure = false;
     private boolean open = false;
-    private map<any> attributes = {};
+    private final map<string|int> attributes = {};
     private boolean initializedByService = false;
 
     private WebSocketConnector conn = new;
@@ -35,35 +37,35 @@ public client class Caller {
     #
     # + data - Data to be sent.
     # + return  - A `websocket:Error` if an error occurs when sending
-    remote isolated function writeTextMessage(string data) returns Error? {
-        return self.conn.writeTextMessage(data);
-    }
+    remote isolated function writeTextMessage(string data) returns Error? = @java:Method {
+        'class: "org.ballerinalang.net.websocket.actions.websocketconnector.WebSocketConnector"
+    } external;
 
     # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,
     # that message will be lost.
     #
     # + data - Binary data to be sent
     # + return  - A `websocket:Error` if an error occurs when sending
-    remote isolated function writeBinaryMessage(byte[] data) returns Error? {
-        return self.conn.writeBinaryMessage(data);
-    }
+    remote isolated function writeBinaryMessage(byte[] data) returns Error? = @java:Method {
+        'class: "org.ballerinalang.net.websocket.actions.websocketconnector.WebSocketConnector"
+    } external;
 
     # Pings the connection. If an error occurs while sending the ping frame to the server, that frame will be lost.
     #
     # + data - Binary data to be sent
     # + return  - A `websocket:Error` if an error occurs when sending
-    remote isolated function ping(byte[] data) returns Error? {
-        return self.conn.ping(data);
-    }
+    remote isolated function ping(byte[] data) returns Error? = @java:Method {
+        'class: "org.ballerinalang.net.websocket.actions.websocketconnector.WebSocketConnector"
+    } external;
 
     # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that
     # the frame will be lost.
     #
     # + data - Binary data to be sent
     # + return  - A `websocket:Error` if an error occurs when sending
-    remote isolated function pong(byte[] data) returns Error? {
-        return self.conn.pong(data);
-    }
+    remote isolated function pong(byte[] data) returns Error? = @java:Method {
+        'class: "org.ballerinalang.net.websocket.actions.websocketconnector.WebSocketConnector"
+    } external;
 
     # Closes the connection.
     #
@@ -77,58 +79,80 @@ public client class Caller {
     # + return - A `websocket:Error` if an error occurs when sending
     remote isolated function close(int? statusCode = 1000, string? reason = (),
         decimal timeout = 60) returns Error? {
-        return self.conn.close(statusCode, reason, timeout);
+        int code = 1000;
+        if (statusCode is int) {
+            if (statusCode <= 999 || statusCode >= 1004 && statusCode <= 1006 || statusCode >= 1012 &&
+                statusCode <= 2999 || statusCode > 4999) {
+                string errorMessage = "Failed to execute close. Invalid status code: " + statusCode.toString();
+                return error ConnectionClosureError(errorMessage);
+            }
+            code = statusCode;
+        }
+        return self.externClose(code, reason is () ? "" : reason, timeout);
     }
 
+    isolated function externClose(int statusCode, string reason, decimal timeoutInSecs) returns Error? = @java:Method {
+        'class: "org.ballerinalang.net.websocket.actions.websocketconnector.Close"
+    } external;
+
     # Sets a connection related attribute.
     #
     # + key - The key, which identifies the attribute
     # + value - The value of the attribute
-    public isolated function setAttribute(string key, any value) {
-        self.attributes[key] = value;
+    public isolated function setAttribute(string key, string|int value) {
+        lock {
+            self.attributes[key] = value;
+        }
     }
 
     # Gets connection related attribute if any.
     #
     # + key - The key to identify the attribute
     # + return - The attribute related to the given key or `nil`
-    public isolated function getAttribute(string key) returns any {
-        return self.attributes[key];
+    public isolated function getAttribute(string key) returns string|int? {
+        lock {
+            return self.attributes[key];
+        }
     }
 
     # Removes connection related attribute if any.
     #
     # + key - The key to identify the attribute
     # + return - The attribute related to the given key or `nil`
-    public isolated function removeAttribute(string key) returns any {
-        return self.attributes.remove(key);
+    public isolated function removeAttribute(string key) returns string|int? {
+        lock {
+            return self.attributes.remove(key);
+        }
     }
 
     # Gives the connection id associated with this connection.
     #
     # + return - The unique ID associated with the connection
-    public isolated function getConnectionId() returns string {
-        return self.id;
-    }
+    public isolated function getConnectionId() returns string = @java:Method {
+        'class: "org.ballerinalang.net.websocket.client.SyncInitEndpoint"
+    } external;
 
     # Gives the subprotocol if any that is negotiated with the client.
     #
     # + return - The subprotocol if any negotiated with the client or `nil`
-    public isolated function getNegotiatedSubProtocol() returns string? {
-        return self.negotiatedSubProtocol;
-    }
+    public isolated function getNegotiatedSubProtocol() returns string? = @java:Method {
+        'class: "org.ballerinalang.net.websocket.client.SyncInitEndpoint",
+        name: "getNegotiatedSubProtocol"
+    } external;
 
     # Gives the secured status of the connection.
     #
     # + return - `true` if the connection is secure
-    public isolated function isSecure() returns boolean {
-        return self.secure;
-    }
+    public isolated function isSecure() returns boolean= @java:Method {
+        'class: "org.ballerinalang.net.websocket.client.SyncInitEndpoint"
+    } external;
 
     # Gives the open or closed status of the connection.
     #
     # + return - `true` if the connection is open
     public isolated function isOpen() returns boolean {
-        return self.open;
+        lock {
+            return self.open;
+        }
     }
 }
diff --git a/websocket-native/src/main/java/org/ballerinalang/net/websocket/WebSocketUtil.java b/websocket-native/src/main/java/org/ballerinalang/net/websocket/WebSocketUtil.java
index d5180f086..82c5e9d92 100644
--- a/websocket-native/src/main/java/org/ballerinalang/net/websocket/WebSocketUtil.java
+++ b/websocket-native/src/main/java/org/ballerinalang/net/websocket/WebSocketUtil.java
@@ -82,13 +82,15 @@ public class WebSocketUtil {
         webSocketCaller.addNativeData(NATIVE_DATA_MAX_FRAME_SIZE, wsService.getMaxFrameSize());
 
         webSocketCaller.set(WebSocketConstants.LISTENER_CONNECTOR_FIELD, webSocketConnector);
-        populateWebSocketEndpoint(webSocketConnection, webSocketCaller);
+        populateClientWebSocketEndpoint(webSocketConnection, webSocketCaller);
         webSocketCaller.set(INITIALIZED_BY_SERVICE, true);
         WebSocketConnectionInfo connectionInfo =
                 new WebSocketConnectionInfo(wsService, webSocketConnection, webSocketCaller);
         connectionManager.addConnection(webSocketConnection.getChannelId(), connectionInfo);
         webSocketConnector.addNativeData(WebSocketConstants.NATIVE_DATA_WEBSOCKET_CONNECTION_INFO,
                 connectionInfo);
+        webSocketCaller.addNativeData(WebSocketConstants.NATIVE_DATA_WEBSOCKET_CONNECTION_INFO,
+                connectionInfo);
         //Observe new connection
         WebSocketObservabilityUtil.observeConnection(
                 connectionManager.getConnectionInfo(webSocketConnection.getChannelId()));
@@ -105,13 +107,13 @@ public class WebSocketUtil {
         webSocketClient.set(WebSocketConstants.LISTENER_IS_OPEN_FIELD, webSocketConnection.isOpen());
     }
 
-    public static void populateWebSocketEndpoint(WebSocketConnection webSocketConnection, BObject webSocketClient) {
-        webSocketClient.set(WebSocketConstants.LISTENER_ID_FIELD,
+    public static void populateWebSocketEndpoint(WebSocketConnection webSocketConnection, BObject webSocketCaller) {
+        webSocketCaller.set(WebSocketConstants.LISTENER_ID_FIELD,
                 StringUtils.fromString(webSocketConnection.getChannelId()));
-        webSocketClient.set(WebSocketConstants.LISTENER_NEGOTIATED_SUBPROTOCOLS_FIELD,
+        webSocketCaller.set(WebSocketConstants.LISTENER_NEGOTIATED_SUBPROTOCOLS_FIELD,
                 StringUtils.fromString(webSocketConnection.getNegotiatedSubProtocol()));
-        webSocketClient.set(WebSocketConstants.LISTENER_IS_SECURE_FIELD, webSocketConnection.isSecure());
-        webSocketClient.set(WebSocketConstants.LISTENER_IS_OPEN_FIELD, webSocketConnection.isOpen());
+        webSocketCaller.set(WebSocketConstants.LISTENER_IS_SECURE_FIELD, webSocketConnection.isSecure());
+        webSocketCaller.set(WebSocketConstants.LISTENER_IS_OPEN_FIELD, webSocketConnection.isOpen());
     }
 
     public static void handleWebSocketCallback(Future balFuture,
